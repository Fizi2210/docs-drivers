= Advanced connection information

include::{common-partial}/connect-advanced.adoc[tag=connection-uri]

include::{common-partial}/connect-advanced.adoc[tag=connection-protocols]


== Authentication methods


=== Basic authentication (default)

The basic authentication scheme relies on traditional username and password.
These can either be the credentials for your local installation, or the ones provided with an Aura instance.

[source, python]
----
from neo4j import GraphDatabase

driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
----

[INFO]
The basic authentication scheme can also be used to authenticate against an LDAP server (Enterprise Edition only).


=== Kerberos authentication

The Kerberos authentication scheme requires a base64-encoded ticket.
It can only be used if the server has the link:{neo4j-docs-base-uri}/kerberos-add-on/current/deployment/[Kerberos Add-on installed].

[source, python, test-skip]
----
from neo4j import GraphDatabase, kerberos_auth

driver = GraphDatabase.driver(URI, auth=kerberos_auth(ticket))
----


=== Bearer authentication

The bearer authentication scheme requires a base64-encoded token provided by an Identity Provider through Neo4j's link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/sso-integration[Single Sign-On feature].

[source, python, test-skip]
----
from neo4j import GraphDatabase, bearer_auth

driver = GraphDatabase.driver(URI, auth=bearer_auth(token))
----

[NOTE]
The bearer authentication scheme requires link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/sso-integration[configuring Single Sign-On on the server].
Once configured, clients can discover Neo4j's configuration through the link:https://neo4j.com/docs/http-api/current/endpoints/#discovery-api[Discovery API].


=== Custom authentication

Use the function link:{neo4j-docs-base-uri}/api/python-driver/current/api.html#neo4j.custom_auth[`custom_auth`] to log into a server having a custom authentication scheme.


=== No authentication

If authentication is disabled on the server, the authentication parameter can be omitted entirely.


[#mtls]
[role=label--new-5.27]
== Mutual TLS (client-side certificates as 2FA)

Mutual TLS (mTLS) allows you to use a client certificate as second factor for authenticating with the server.
The certificate can only be used together with an authentication token and is not a replacement of regular authentication, unless authentication is disabled on the server.

[NOTE]
must use a secure driver with client certificates (...+s[sc] scheme or encrypted=True)
# ex. "neo4j+s://example.com:7687"

[.tabbed-example]
=====
[.include-with-static-certificate]
======
Use link:https://neo4j.com/docs/api/python-driver/current/api.html#neo4j.auth_management.ClientCertificateProviders.static[`ClientCertificateProviders.static()`] for static certificates. +
The method takes a link:https://neo4j.com/docs/api/python-driver/current/api.html#neo4j.auth_management.ClientCertificate[`ClientCertificate`] instance.

[source, python, test-skip]
----
import neo4j
from neo4j.auth_management import (
    ClientCertificate,
    ClientCertificateProviders,
)


URI = "<URI for Neo4j database>"
AUTH = ("<Username>", "<Password>")


cert_provider = ClientCertificateProviders.static(
    ClientCertificate(
        # path to public certificate to load
        "path/to/cert.pem",
        # path to private key to load
        "path/to/key.pem",
        # password to decrypt private key (can be a function or string)
        # see also Python's ssl.SSLContext.load_cert_chain()
        lambda: "password",
    )
)

with neo4j.GraphDatabase.driver(
    URI,
    auth=AUTH,
    client_certificate=cert_provider,
) as driver:
    ...
----

======
[.include-with-rotating-certificate]
======

Use link:https://neo4j.com/docs/api/python-driver/current/api.html#neo4j.auth_management.ClientCertificateProviders.rotating[`ClientCertificateProviders.rotating()`] for rotating certificates. +
The method takes a link:https://neo4j.com/docs/api/python-driver/current/api.html#neo4j.auth_management.ClientCertificate[`ClientCertificate`] instance.

[source, python, test-skip]
----
import neo4j
from neo4j.auth_management import (
    ClientCertificate,
    ClientCertificateProviders,
)

URI = "<URI for Neo4j database>"
AUTH = ("<Username>", "<Password>")


cert_provider = ClientCertificateProviders.rotating(
    ClientCertificate(
        # path to public certificate to load
        "path/to/cert.pem",
        # path to private key to load
        "path/to/key.pem",
        # password to decrypt private key (can be a function or string)
        # see also Python's ssl.SSLContext.load_cert_chain()
        lambda: "password",
    )
)
driver = neo4j.GraphDatabase.driver(
   URI
   auth=(USERNAME, PASSWORD),
   client_certificate=cert_provider
)

# do work with the driver, until the certificate needs to be rotated
# ...

cert_provider.update_certificate(
    ClientCertificate(
        certfile="path/to/new/certfile.pem",
        keyfile="path/to/new/keyfile.pem",
        password=lambda: "new_super_secret_password"
    )
)

# do more work with the driver, until the certificate needs to be
# rotated again
# ...
----

======
=====


For more information, see link:https://neo4j.com/docs/api/python-driver/current/api.html#neo4j.auth_management.ClientCertificateProvider[API docs -> `ClientCertificateProvider`].


== Custom address resolver

When creating a `Driver` object, you can specify a _resolver_ function to resolve any addresses the driver receives ahead of DNS resolution.
Your resolver function is called with an link:{neo4j-docs-base-uri}/api/python-driver/current/api.html#neo4j.Address[`Address`] object and should return an iterable of link:{neo4j-docs-base-uri}/api/python-driver/current/api.html#neo4j.Address[`Address`] objects (or values that can be used to construct `Address` objects)

.Connection to `example.com` on port `9999` is resolved to `localhost` on port `7687`
[source, python]
----
import neo4j


def custom_resolver(socket_address):
    # assert isinstance(socket_address, neo4j.Address)
    if socket_address != ("example.com", 9999):
        raise OSError(f"Unexpected socket address {socket_address!r}")

    # You can return any neo4j.Address object
    yield neo4j.Address(("localhost", 7687))  # IPv4
    yield neo4j.Address(("::1", 7687, 0, 0))  # IPv6
    yield neo4j.Address.parse("localhost:7687")
    yield neo4j.Address.parse("[::1]:7687")

    # or any tuple that can be passed to neo4j.Address().
    # This will initially be interpreted as IPv4, but DNS resolution
    # will turn it into IPv6 if appropriate.
    yield "::1", 7687
    # This will be interpreted as IPv6 directly, but DNS resolution will
    # still happen.
    yield "::1", 7687, 0, 0
    yield "127.0.0.1", 7687


driver = neo4j.GraphDatabase.driver("neo4j://example.com:9999",
                                    auth=(USERNAME, PASSWORD),
                                    resolver=custom_resolver)
----


== Further connection parameters

You can find all `Driver` configuration parameters in the link:{neo4j-docs-base-uri}/api/python-driver/current/api.html#driver-configuration[API documentation].


ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
include::../partials/glossary.adoc[]
endif::[]
