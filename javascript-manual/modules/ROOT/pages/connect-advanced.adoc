= Advanced connection information

include::{common-partial}/connect-advanced.adoc[tag=connection-uri]

include::{common-partial}/connect-advanced.adoc[tag=connection-protocols]


== Authentication methods


=== Basic authentication

The basic authentication scheme relies on traditional username and password.
These can either be the credentials for your local installation, or the ones provided with an Aura instance.

[source, javascript]
----
const driver = neo4j.driver(URI, neo4j.auth.basic(USER, PASSWORD))
----

[INFO]
The basic authentication scheme can also be used to authenticate against an LDAP server (Enterprise Edition only).


=== Kerberos authentication

The Kerberos authentication scheme requires a base64-encoded ticket.
It can only be used if the server has the link:{neo4j-docs-base-uri}/kerberos-add-on/current/deployment/[Kerberos Add-on installed].

[source, javascript, test-skip]
----
const driver = neo4j.driver(URI, neo4j.auth.kerberos(ticket))
----


=== Bearer authentication

The bearer authentication scheme requires a base64-encoded token provided by an Identity Provider through Neo4j's link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/sso-integration[Single Sign-On feature].

[source, javascript, test-skip]
----
const driver = neo4j.driver(URI, neo4j.auth.bearer(token))
----

[NOTE]
The bearer authentication scheme requires link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/sso-integration[configuring Single Sign-On on the server].
Once configured, clients can discover Neo4j's configuration through the link:https://neo4j.com/docs/http-api/current/endpoints/#discovery-api[Discovery API].


=== Custom authentication

If the server is equipped with a custom authentication scheme, use `neo4j.auth.custom`.

[source, javascript, test-skip]
----
const driver = neo4j.driver(
  URI,
  neo4j.auth.custom(principal, credentials, realm, scheme, parameters)
)
----


=== No authentication

If authentication is disabled on the server, the authentication parameter can be omitted entirely.


[role=label--new-5.14]
== Rotating authentication tokens

It is possible to rotate authentication tokens that are expected to expire (e.g. SSO).
You need to provide a link:https://neo4j.com/docs/api/javascript-driver/current/class/lib6/auth-token-manager.js~AuthTokenManager.html[`AuthTokenManager`] instance when instantiating the `Driver`, rather than a static authentication token.

The easiest way to get started is to use link:https://neo4j.com/docs/api/javascript-driver/current/class/lib6/auth-token-manager.js~AuthTokenManagers.html[one of built-in `AuthTokenManager` implementations].

.Rotating a bearer token expiring every 60 seconds
[source, javascript, test-skip]
----
import neo4j, { AuthToken } from 'neo4j-driver'

/**
 * Method called whenever the driver needs to refresh the token.
 *
 * The refresh will happen if the driver is notified by the server
 * of token expiration, or if `Date.now() > tokenData.expiry`.
 *
 * The driver will block creation of all connections until
 * this function resolves the new auth token.
 */
async function generateAuthToken () {
   const bearer = await getSSOToken()
   const token = neo4j.auth.bearer(bearer)

   // assume we know tokens expire every 60 seconds
   const expiresIn = 60
   // Include a little buffer so that new token is fetched before the old one expires
   const expiration = expiresIn - 10

   return {
      token,
      // if expiration is not provided,
      // the driver will only fetch a new token when an auth failure happens
      expiration
   }
}

const driver = neo4j.driver(
    URI,
    neo4j.expirationBasedAuthTokenManager({
        tokenProvider: generateAuthToken
    })
)
----

[WARNING]
This API should not be used for switching users. Auth managers should always return tokens for the same identity.
You can switch users at both xref:query-simple.adoc#impersonation[query level] and xref:transactions.adoc#impersonation[session level].

[WARNING]
`AuthManagers` (including provider functions passed to `expirationBasedAuthTokenManager()`) must not interact with the driver in any way, as this can cause deadlocks and undefined behavior.


== Custom address resolver

When creating a `Driver` object, you can specify a _resolver_ function to resolve the connection address the driver is initialized with.
Note that addresses that the driver receives in routing tables are not resolved with the custom resolver.

.Connection to `example.com` on port `9999` is resolved to `localhost` on port `7687`
[source, javascript]
----
let URI = 'neo4j://example.com:9999'
let addresses = [
  'localhost:7687'
]
let driver = neo4j.driver(URI, neo4j.auth.basic(USER, PASSWORD), {
  resolver: address => addresses
})
----


== Further connection parameters

You can find all `Driver` configuration parameters in the link:{neo4j-docs-base-uri}/api/javascript-driver/current/function/index.html#static-function-driver[API documentation].


ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
include::../partials/glossary.adoc[]
endif::[]
